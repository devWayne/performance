# 阻塞页面渲染的场景

大多数设备的刷新频率是 60 次/秒，（1000/60 = 16.6ms）也就说是浏览器对每一帧画面的渲染工作要在 16ms 内完成，超出这个时间，页面的渲染就会出现卡顿现象，影响用户体验。


## 16ms渲染帧

浏览器在一帧里面，会依次执行以下这些动作。

![](https://gw.alicdn.com/tfs/TB1FemYmwMPMeJjy1XbXXcwxVXa-926-99.png)

JavaScript：JavaScript 实现动画效果，DOM 元素操作等。
Style（计算样式）：确定每个 DOM 元素应该应用什么 CSS 规则。
Layout（布局）：计算每个 DOM 元素在最终屏幕上显示的大小和位置。由于 web 页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫 reflow。
Paint（绘制）：在多个层上绘制 DOM 元素的的文字、颜色、图像、边框和阴影等。
Composite（渲染层合并）：按照合理的顺序合并图层然后显示到屏幕上。


## LocalStorge

https://nolanlawson.com/2015/09/29/indexeddb-websql-localstorage-what-blocks-the-dom/

indexedDB VS LocalStorage

　　IndexedDB和LocalStorage都是用来在浏览器里存储数据，但它们使用不同的技术，有不同的用途，你需要根据自己的情况适当的选择使用哪种。LocalStorage是用key-value键值模式存储数据，但跟IndexedDB不一样的是，它的数据并不是按对象形式存储。它存储的数据都是字符串形式。如果你想让LocalStorage存储对象，你需要借助JSON.stringify()能将对象变成字符串形式，再用JSON.parse()将字符串还原成对象。但如果要存储大量的复杂的数据，这并不是一种很好的方案。毕竟，localstorage就是专门为小数量数据设计的，它的api是同步的。

IndexedDB很适合存储大量数据，它的API是异步调用的。IndexedDB使用索引存储数据，各种数据库操作放在事务中执行。IndexedDB甚至还支持简单的数据类型。IndexedDB比localstorage强大得多，但它的API也相对复杂。

　　对于简单的数据，你应该继续使用localstorage，但当你希望存储大量数据时，IndexedDB会明显的更适合，IndexedDB能提供你更为复杂的查询数据的方式。




##  减少reflow带来的性能损耗

#### 布局(Layout)

渲染树生成后，浏览器会从页面左上角开始迭代地计算出每个元素尺寸和位置，最终生成布局。这个过程可能是一气呵成的，但也可能由于元素的排列导致反复地绘制。元素间的位置关系都紧密相关。为了优化必要的任务，浏览器会追踪元素的变化情况，并将这些元素以及它们的子节点标记为 ‘dirty’（脏元素）。但是元素间耦合紧密，任何布局上的改变代价都是重大的，应该尽量避免。

#### 绘制(Paint)

生成布局后，浏览器将页面绘制到屏幕上。这个环节和「布局」步骤类似，浏览器会追踪脏元素，将它们合并到一个超大的矩形区域中。每一帧内只会发生一次重绘，用于绘制这个被污染区域。重绘也会消耗大量性能，能免则免。

#### 复合(Composite)

最后一步，将所有绘制好的元素进行复合。默认情况下，所有元素将会被绘制到同一个层中；如果将元素分开到不同的复合层中，更新元素对性能友好，不在同一层的元素不容易受到影响。CPU 绘制层，GPU 生成层。基础绘图操作在硬件加速合成中完成效率高。层的分离允许非破坏性的改变，正如你所猜测的，GPU 复合层上的改变代价最小性能消耗最少。


在这三个步骤中，布局的改变会使浏览器需要重新计算渲染树,对浏览器的性能开销最大，甚至会丢失一次帧的绘制


#### 下列情况会发生重排（reflow）

1. 页面初始渲染
2. 添加/删除可见DOM元素
3. 改变元素位置
4. 改变元素尺寸（宽、高、内外边距、边框等）
5. 改变元素内容（文本或图片等）
6. 改变窗口尺寸


#### 优化方案

1. 对于素位置的改变可以通过改变元素的 transform 实现移动，利用 GPU 加速优先使用渲染层合并属性, 伸缩变换而非改变物体的 left，top，width，height 避免 layout，paint。让动画效果更加流畅。

```
@keyframes demo {
  0% {
      top: 10px;
  }
  100% {
      top: 30px;
  }
}
```

to 

```
@keyframes demo {
  0% {
      transform: translateY(10px);
  }
  100% {
      transform: translateY(30px);
  }
}
```


2. 对于改变可视状态的场景可以使用visibility,opacity等属性代替display

3. 对于频繁的操作修改dom节点的场景，可以先把 DOM 离线后修改。先把 DOM 给 display:none (有一次 Reflow)，然后进行节点的修改（不产生新的Reflow），最后把修改完的dom再显示出来。


